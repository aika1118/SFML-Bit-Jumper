#include "Player.h"
#include "Game.h" // 순환참조 회피

void Player::Begin()
{
	// Animation Frame 정의
	_runAnimation = Animation(1.1f,
		{
			AnimFrame(0.1f, Resources::_textures["walk0001.png"]),
			AnimFrame(0.2f, Resources::_textures["walk0002.png"]),
			AnimFrame(0.3f, Resources::_textures["walk0003.png"]),
			AnimFrame(0.4f, Resources::_textures["walk0004.png"]),
			AnimFrame(0.5f, Resources::_textures["walk0005.png"]),
			AnimFrame(0.6f, Resources::_textures["walk0006.png"]),
			AnimFrame(0.7f, Resources::_textures["walk0007.png"]),
			AnimFrame(0.8f, Resources::_textures["walk0008.png"]),
			AnimFrame(0.9f, Resources::_textures["walk0009.png"]),
			AnimFrame(1.0f, Resources::_textures["walk0010.png"])
		});


	b2BodyDef bodyDef; // 물리적 몸체 정의
	b2FixtureDef fixtureDef;

	bodyDef.type = b2_dynamicBody;  // 물체가 물리 시뮬레이션에서 중력, 충돌, 힘 등과 같은 외부 요인의 영향을 받음
	bodyDef.position.Set(_position.x, _position.y);
	bodyDef.fixedRotation = true; // 물체가 회전하지 않도록 설정
	body = Physics::world->CreateBody(&bodyDef); // body = 새로 생성된 몸체에 대해 포인터로 참조가능

	_fixtureData.listener = this;
	_fixtureData.player = this;
	_fixtureData.type = FixtureDataType::Player;

	
	fixtureDef.userData.pointer = (uintptr_t)&_fixtureData; // 차후 Contact 상황 등에서 fixture를 통해 fixtureData 접근 가능
	fixtureDef.density = 1.f; // 밀도
	fixtureDef.friction = 0.f; // 마찰

	// 캐릭터를 감싸는 충돌체
	b2PolygonShape polygonShape;
	polygonShape.SetAsBox(0.5f, PLAYER_NORMALIZED_HEIGHT / 2.f);
	fixtureDef.shape = &polygonShape;
	body->CreateFixture(&fixtureDef);

	// 캐릭터 발 밑에 설치할 sensor (땅에 닿을 때 점프 처리를 위한 sensor)

	b2FixtureDef sensorFixtureDef;
	b2PolygonShape sensorPolygonShape;

	_sensorFixtureData.listener = this;
	_sensorFixtureData.player = this;
	_sensorFixtureData.type = FixtureDataType::PlayerSensor;

	sensorFixtureDef.userData.pointer = (uintptr_t)&_sensorFixtureData; // 차후 Contact 상황 등에서 fixture를 통해 fixtureData 접근 가능
	sensorPolygonShape.SetAsBox(PLAYER_SENSOR_HX, PLAYER_SENSOR_HY, b2Vec2(0.f, PLAYER_NORMALIZED_HEIGHT / 2.f), 0.f);
	sensorFixtureDef.isSensor = true; // sensor : 충돌을 감지하지만 물리적인 상호작용은 하지 않는 특수한 fixture
	sensorFixtureDef.shape = &sensorPolygonShape;

	body->CreateFixture(&sensorFixtureDef);

	// 이외 멤버함수 초기화
	_hp = 3;
	_isDead = false;
	_playerStatus = PlayerStatus::Idle;
}

void Player::Update(float deltaTime)
{
	_position = Vector2f(body->GetPosition().x, body->GetPosition().y); // Physics::Update()에서 world.Step에 의해 프레임 당 물리 계산 적용중, 이로 인해 body position 변화 발생
	_angle = body->GetAngle() * (180.f / M_PI); // 라디안에서 도(degree) 변환
	b2Vec2 velocity = body->GetLinearVelocity();
	
	HandleSkill(deltaTime, velocity); // 키보드 입력에 따라 skill 처리
	HandleMove(deltaTime, velocity); // 키보드 입력에 따라 move 처리
	HandleJump(velocity); // 키보드 입력에 따라 jump 처리
	body->SetLinearVelocity(velocity);
}

void Player::Draw(Renderer& renderer)
{
	if (_playerStatus == PlayerStatus::Attacking) // 스킬 사용 중일 때는 스킬 렌더링
	{
		SkillManager::getInstance().Render(renderer, _currentSkillId);
		return;
	}

	renderer.Draw(_textureToDraw, _position, Vector2f(_facingLeft ? -1.f : 1.f, PLAYER_NORMALIZED_HEIGHT), _angle); // 캐릭터가 왼쪽 바라보면 size.x에 음수 적용
}

Player::~Player()
{
}

void Player::OnBeginContact(b2Fixture* self, b2Fixture* other)
{
	FixtureData* selfData = (FixtureData*)self->GetUserData().pointer; // self
	FixtureData* otherData = (FixtureData*)other->GetUserData().pointer; // other

	if (!selfData) return;
	if (!otherData)	return;

	// player가 mapTile과 닿아있는 경우
	if (selfData->type == FixtureDataType::PlayerSensor && otherData->type == FixtureDataType::MapTile) 
	{
		++_groundContactCount; 

		// jump 상태 초기화
		_jumpCount = 0; 
		_isJumping = false;

		return;
	}

	// player가 coin과 충돌한 경우
	if (selfData->type == FixtureDataType::Player && otherData->type == FixtureDataType::Object && otherData->object->_tag == "coin")
	{
		Coin* coin = dynamic_cast<Coin*>(otherData->object); // 안전하게 다운 캐스팅 (otherData->object가 Coin*이 아닐경우 nullptr 반환)
		if (!coin)
			return;
		
		coin->destroyBody(); // world에서 body를 destroy (정확히는 삭제 대기리스트에만 일단 추가 후 Physics에서 step 계산 후 일괄적으로 destroyBody 진행)
		Game::getInstance().DeleteObject(otherData->object); // object를 destroy하여 더이상 해당 object에 대해 update, render되지 않도록 함

		++_coins;

		cout << "coins = " << _coins << endl;

		return;
	}

	// player가 적과 충돌한 경우
	if (otherData->type == FixtureDataType::Object && otherData->object->_tag == "enemy")
	{
		Enemy* enemy = dynamic_cast<Enemy*>(otherData->object);
		if (!enemy)
			return;

		// player 발 밑 센서로 적과 충돌한 경우 물리적 몸체만 먼저 destroy
		// texture는 일정시간 동안 죽은 모습으로 계속 그림 (이후 objects에서 delete 처리 될 예정)
		if (selfData->type == FixtureDataType::PlayerSensor)
			enemy->destroyBody();

		// enemy가 살아있고 player가 적과 일반적으로 충돌한 경우 피격처리
		else if (enemy->IsDead() == false)
		{
			_hp = max(0, _hp - 1);
			cout << _hp << endl;

			if (_hp <= 0)
				_isDead = true;
		}

		return;
	}

	// player가 save 타일과 충돌한 경우
	// 최근에 충돌한 save 타일에 리스폰 위치 지정하는 작업
	if (selfData->type == FixtureDataType::Player && otherData->type == FixtureDataType::SaveTile)
	{
		int preSaveX = Game::getInstance()._savePositionX;
		int preSaveY = Game::getInstance()._savePositionY;
		int curSaveX = otherData->mapX;
		int curSaveY = otherData->mapY;
		
		// 이전에 세이브한 장소와 동일한 경우 바로 return 처리
		if (preSaveX == curSaveX && preSaveY == curSaveY)
			return;

		// 현재 세이브 장소의 texture를 save_used.png로 변경
		Map::getInstance()._grid[curSaveX][curSaveY] = &Resources::_textures["save_used.png"];

		// 이전 세이브 기록이 있는 경우 이전 세이브 블록을 원본으로 돌려놓음
		if (preSaveX || preSaveY)
			Map::getInstance()._grid[preSaveX][preSaveY] = &Resources::_textures["save.png"];

		// 최근 세이브 장소를 Game 클래스에 기록
		Game::getInstance()._savePositionX = curSaveX;
		Game::getInstance()._savePositionY = curSaveY;
	}
}

void Player::OnEndContact(b2Fixture* self, b2Fixture* other)
{
	FixtureData* selfData = (FixtureData*)self->GetUserData().pointer; // self
	FixtureData* otherData = (FixtureData*)other->GetUserData().pointer; // other

	if (!selfData) return;
	if (!otherData)	return;

	if (selfData->type == FixtureDataType::PlayerSensor && otherData->type == FixtureDataType::MapTile) // player가 mapTile과 멀어지는 경우
	{
		_groundContactCount = _groundContactCount > 0 ? --_groundContactCount : _groundContactCount;
		return;
	}
}

void Player::HandleMove(float deltaTime, b2Vec2& velocity)
{
	if (_playerStatus == PlayerStatus::Attacking) // skill 사용 중이면 return
		return;

	float move = PLAYER_MOVE_VELOCITY;

	if (Keyboard::isKeyPressed(Keyboard::LShift)) // shift 키다운 시 이동속도 2배
		move *= 2;

	
	velocity.x = 0.f;

	if (Keyboard::isKeyPressed(Keyboard::Right))
		velocity.x = +move;
	if (Keyboard::isKeyPressed(Keyboard::Left))
		velocity.x = -move;

	// 현재 time에 따라 draw할 texture 얻기
	_runAnimation.Update(deltaTime);
	_textureToDraw = _runAnimation.GetTexture();

	if (velocity.x < -0.02f)
		_facingLeft = true;
	else if (velocity.x > 0.02f)
		_facingLeft = false;
	else
		_textureToDraw = Resources::_textures["idle.png"]; // 캐릭터가 정지중일 때 적용할 animation texture
}

void Player::HandleJump(b2Vec2& velocity)
{
	if (_playerStatus == PlayerStatus::Attacking) // skill 사용 중이면 return
		return;

	// PLAYER_MAX_JUMP_COUNT 횟수만큼 점프 가능하도록 구현 (최초 점프는 땅에서만 가능)
	bool currentSpaceState = Keyboard::isKeyPressed(Keyboard::Space); // 프레임 별로 keyDown, keyReleased 판별을 위한 상태변수

	// KeyDown: Space 키가 눌렸고, 이전 프레임에서는 떼어져 있었다면
	if (currentSpaceState && !_previousSpaceState)
	{
		if (_groundContactCount > 0) // 최초 땅에서 점프하는 순간
		{
			velocity.y = PLAYER_JUMP_VELOCITY;
			_isJumping = true;
		}

		else if (1 <= _jumpCount && _jumpCount < PLAYER_MAX_JUMP_COUNT) // 이미 점프한 후 연속 점프 시도 상황
		{
			velocity.y = PLAYER_JUMP_VELOCITY;
			_isJumping = true;
		}
	}

	// KeyReleased: Space 키가 떼어졌을 때
	if (!currentSpaceState && _previousSpaceState) {
		if (_isJumping) // space 키다운으로 유효한 점프 상황에서 key released 되었을 때 (그냥 땅에서 떨어지며 공중에서 점프하는 것 방지)
		{
			++_jumpCount;
			_isJumping = false;
		}
	}

	_previousSpaceState = currentSpaceState;

	if (_groundContactCount <= 0)
		_textureToDraw = Resources::_textures["jump.png"]; // 캐릭터가 점프중일 때 (지면에 없을 떄) 적용할 animation texture
}

void Player::HandleSkill(float deltaTime, b2Vec2& velocity)
{
	if (_playerStatus == PlayerStatus::Attacking) // 이미 skill 사용 중일 떄
	{
		// 스킬 애니메이션 업데이트
		// 스킬 사용 시간이 끝난 경우 playerStatus를 Idle로 변경
		SkillManager::getInstance().Update(deltaTime, _currentSkillId);
		
		if (SkillManager::getInstance().isSkillEnd(_currentSkillId))
			_playerStatus = PlayerStatus::Idle;

		return;
	}

	if (Keyboard::isKeyPressed(Keyboard::Q)) // 근접공격
	{
		velocity = b2Vec2(0.f, 0.f); // 스킬 사용 전 캐릭터 속도를 0으로 만듦
		_playerStatus = PlayerStatus::Attacking;
		_currentSkillId = (int)SkillList::MELEE_ATTACK;

		// 스킬 사용
		SkillManager::getInstance().Begin(_currentSkillId);
	}
		
}
