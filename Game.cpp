#include "Game.h"


Game::Game() // 참조자 멤버변수 초기화
	:gameMap(Map::getInstance()), camera(Camera::getInstance())
{
	if (Util::checkServerConnection() == false)
	{
		cout << "Offline Mode !" << endl;
		_isServerConnected = false;
		return; // 서버 연결을 원하지 않는 경우 (config.h에서 값 관리)
	}

	try
	{
		client = new Client(io_context, SERVER_IP, SERVER_PORT); // 클라이언트 생성
		cout << "Client Connected !" << endl;
	}
	catch (const std::exception& e)
	{
		cerr << "Exception: " << e.what() << "\n"; // 예외처리
	}

	Physics::Init();
	_enemyPool = new EnemyPool();
}

int Game::getUid() const
{
	return _uid;
}

void Game::setUid(int uid)
{
	_uid = uid;
}

Game& Game::getInstance()
{
	static Game instance; // 인스턴스는 최초 호출 시에만 생성됨
	return instance;
}


void Game::Begin(RenderWindow& window)
{
	for (const auto& file : filesystem::directory_iterator("./resources/textures/")) // 해당 경로에 있는 모든 texture 불러오기
	{
		if (file.is_regular_file() && (file.path().extension() == ".png" || file.path().extension() == ".jpg"))
			Resources::_textures[file.path().filename().string()].loadFromFile(file.path().string()); // unordered_map에 texture 정보 저장
	}

	//for (const auto& file : filesystem::directory_iterator("./resources/sounds/")) // sound 불러오기
	//{
	//	if (file.is_regular_file() && (file.path().extension() == ".ogg" || file.path().extension() == ".wav"))
	//		Resources::_sounds[file.path().filename().string()].loadFromFile(file.path().string()); // unordered_map에 texture 정보 저장
	//}

	//_mapImage.loadFromFile(MAP_STAGE_1);
	//_mapBound = FloatRect(0.f, 0.f, (float)_mapImage.getSize().x, (float)_mapImage.getSize().y); // 현재 mapBound 계산 (view가 맵 경계 벗어나지 않도록 하는 작업)

	if (!font.loadFromFile("./resources/Fonts/ttf/BMDOHYEON_ttf.ttf"))
	{
		cerr << "font load error!" << endl;
		return;
	}

		
	playerJudgementPercentageText.setFont(font);
	playerJudgementPercentageText.setFillColor(Color::White);
	playerJudgementPercentageText.setOutlineColor(Color::Black);
	playerJudgementPercentageText.setOutlineThickness(1.f);
	playerJudgementPercentageText.setScale(UI_CHARACTER_SCALE, UI_CHARACTER_SCALE);

	playerJudgementText.setFont(font);
	playerJudgementText.setFillColor(Color::White);
	playerJudgementText.setOutlineColor(Color::Black);
	playerJudgementText.setOutlineThickness(1.f);
	playerJudgementText.setScale(UI_CHARACTER_SCALE, UI_CHARACTER_SCALE);

	gameOverText.setFont(font);
	gameOverText.setFillColor(Color::White);
	gameOverText.setOutlineColor(Color::Black);
	gameOverText.setOutlineThickness(1.f);
	gameOverText.setScale(UI_CHARACTER_SCALE, UI_CHARACTER_SCALE);

	playerCoinText.setFont(font);
	playerCoinText.setFillColor(Color::White);
	playerCoinText.setOutlineColor(Color::Black);
	playerCoinText.setOutlineThickness(1.f);
	playerCoinText.setScale(UI_CHARACTER_SCALE/1.2f, UI_CHARACTER_SCALE/1.2f);

	backgroundWhenPaused.setSize(Vector2f(1.f, 1.f));
	backgroundWhenPaused.setFillColor(Color(0, 0, 0, 150)); // 알파값만 조정
	backgroundWhenPaused.setOrigin(0.5f, 0.5f); // origin을 중심으로 맞추기

	MenuManager::getInstance().init(window);

	// 서버연결 안되어있으면 진행 스테이지 상황을 기본값으로 초기화 (_uid는 이미 SETTING_UID_NOT_INITED 값으로 초기화되어있음)
	if (_isServerConnected == false) setPlayerCurrentClearStage(getUid(), PLAYER_DEFAULT_STAGE);

	InitSkill();

	Restart();
}

void Game::InitSkill()
{
	// melee skill 초기화
	int meleeStart = (int)SkillList::MELEE_START;
	int meleeEnd = (int)SkillList::MELEE_END;

	for (int skillId = meleeStart + 1; skillId < meleeEnd; ++skillId)
	{
		Skill* skill = new SkillMeleeAttack(skillId); // skillId에 따라 스킬 고유한 객체 생성
		SkillManager::getInstance().AddSkill(skillId, skill); // skillId에 매핑하여 skill을 unordered_map에 추가
	}
}

Vector2f Game::getPlayerPosition()
{
	return player._position;
}

float Game::getPlayerAngle()
{
	return player._angle;
}

bool Game::getPlayerFacingLeft()
{
	return player._facingLeft;
}

Player& Game::getPlayer()
{
	return player;
}

int& Game::getMenuState()
{
	return _menuState;
}

int Game::getStageSelected()
{
	return _stageSelected;
}

void Game::setStageSelected(int stage)
{
	_stageSelected = stage;
}

void Game::setMapImage(int stage)
{
	_mapImage.loadFromFile(Map::getInstance().getMapImages(stage)); // load 실패할 때 예외처리 필요
	_mapBound = FloatRect(0.f, 0.f, (float)_mapImage.getSize().x, (float)_mapImage.getSize().y); // 현재 mapBound 계산 (view가 맵 경계 벗어나지 않도록 하는 작업)
	Restart();
}

void Game::setMenuState(int menuState)
{
	_menuState = menuState;
}

int Game::getPlayerCurrentClearStage(int id)
{
	lock_guard<mutex> lock(playerCurrentClearStages_mutex_);
	return _playerCurrentClearStages[id];
}

void Game::setPlayerCurrentClearStage(int id, int stage)
{
	lock_guard<mutex> lock(playerCurrentClearStages_mutex_);
	_playerCurrentClearStages[id] = stage;
}

float Game::getPlayerStageScore(int id, int stage)
{
	return _playerStageScores[id][stage];
}

void Game::setPlayerStageScore(int id, int stage, float score)
{
	_playerStageScores[id][stage] = score;
}

bool Game::isServerConnected()
{
	return _isServerConnected;
}


Client* Game::getClient()
{
	return client;
}

io_context& Game::getIoContext()
{
	return io_context;
}

string Game::getUsername()
{
	return _username;
}

EnemyPool* Game::GetEnemyPool()
{
	return _enemyPool;
}

void Game::Restart() // Begin할 때의 Restart()가 뭔가 중복되는 것 같아서 코드 정리 필요 (world도 Game 생성자에서 Init하고 Restart()에서 또 Init 되는듯 하여 문제 없을지 확인)
{
	cout << "Restart() Called !" << endl;
	InitObject();  // 현재 world의 object 관련 정보를 담고있는 vector 초기화 (restart 후 이전 object들은 렌더링 되지 않도록)
	Physics::Init(); // 기존 world 초기화
	_enemyPool->Reset(); // enemyPool 초기화

	player = Player(); // 임시 객체를 생성하고, 복사 대입 연산자로 새로 초기화
	gameMap.CreateFromImage(_mapImage, _objects); // map 따라 player 위치 및 object 생성

	player._position = _playerPosition;
	player.Begin();

	for (Object* object : _objects)
		object->Begin();
}

void Game::Update(float deltaTime, RenderWindow& window)
{
	if (_isServerConnected && !_isUidInited) // uid가 초기화 될때까지 해당 if조건에 계속 걸리게됨
	{
		// 현재 닉네임 생성 메뉴에 있다면 return
		if (_menuState == MenuIndex::MAKE_USERNAME_MENU) return;

		_uid = Util::getUID();

		// 아직 세팅파일에 uid가 없는 경우
		if (_uid == SETTING_UID_NOT_INITED) setMenuState(MenuIndex::MAKE_USERNAME_MENU); // 닉네임 생성 메뉴로 이동

		else // 정상적인 uid를 얻은 경우
		{
			_username = Util::getUserName(_uid); // uid를 얻은 경우 username도 get 하기
			_menuState = MenuIndex::MAIN_MENU; // 메인 메뉴로 이동

			// uid에 해당하는 최신 clear stage를 아래 const 값으로 초기화 (실제 db값 받기전에 로딩중을 알리는 처리를 하기 위함 in StageMenu.cpp)
			setPlayerCurrentClearStage(_uid, SETTING_PLAYER_CURRENT_CLEAR_STAGE_NOT_INITED);
			
			// uid에 해당하는 최신 clear stage 정보 받아오기
			if (Game::getInstance().isServerConnected())
				client->send_packet_async(PACKET_READ_MAX_CLEAR_STAGE, to_string(_uid),
					[](const string& response) { // 콜백 정의
						cout << "PACKET_READ_MAX_CLEAR_STAGE callback!" << endl;
						// uid에 해당하는 가장 높이 클리어했던 stage 저장
						Game::getInstance().setPlayerCurrentClearStage(Game::getInstance().getUid(), stoi(response));
						return;
					}
				);
			else // Update() if 조건에서 서버연결을 확인했지만 혹시 몰라 예외처리
				setPlayerCurrentClearStage(_uid, PLAYER_DEFAULT_STAGE);

			_isUidInited = true;
		}
	}

	MenuManager::getInstance().setCurrentMenu(_menuState);

	if (_menuState == MenuIndex::EXIT)
	{
		window.close();
		return;
	}

	// 게임 종료 후 클리어메뉴에 있을 때 메모리 해제 작업 등
	if (_menuState == MenuIndex::CLEAR_MENU)
	{
		Game::getInstance().InitObject();  // 현재 world의 object 관련 정보를 담고있는 vector 초기화 (restart 후 이전 object들은 렌더링 되지 않도록)
		Physics::Shutdown(); // 기존 world 삭제처리
		//Resources::_textures.clear(); // texture는 게임 시작 시 최초 한번 초기화 하고 계속 사용하고 있으니 스테이지 종료 후 별도로 초기화하지 않음
		return;
	}

	if (MenuManager::getInstance().isInMenu()) return;
	

	if (player._isDead && Keyboard::isKeyPressed(Keyboard::Enter)) // 플레이어 사망상태에서 Enter 눌러서 재시작
		Restart(); 

	if (player._isDead) // player 사망상태에서는 update 하지 않음
		return;

	Physics::Update(deltaTime);
	player.Update(deltaTime);
	_enemyPool->Update(deltaTime);
	for (Object* object : _objects)
		object->Update(deltaTime);

	camera._position = player._position;
}

void Game::Render(Renderer& renderer)
{
	if (MenuManager::getInstance().isInMenu())
	{
		renderer._target.setView(renderer._target.getDefaultView()); // 메뉴 UI 표시를 위해 window default view로 회귀
		MenuManager::getInstance().render(renderer);
		return;
	}

	renderer._target.setView(camera.getView(renderer._target.getSize()));

	float backGroundPositionX = _mapBound.left + _mapBound.width / 2;
	float backGroundPositionY = _mapBound.top + _mapBound.height / 2;

	renderer.Draw(Resources::_textures["sky.png"], Vector2f(backGroundPositionX, backGroundPositionY), Vector2f(_mapBound.width, _mapBound.height)); // 배경화면 그리기
	gameMap.Draw(renderer);
	player.Draw(renderer);
	_enemyPool->Render(renderer);

	for (Object* object : _objects)
		object->Render(renderer);

	if (MAP_IS_DEBUG_DRAW)
		Physics::DebugDraw(renderer); 
}

void Game::RenderUI(Renderer& renderer)
{
	if (MenuManager::getInstance().isInMenu()) return;

	renderer._target.setView(camera.getUIView());

	// 판정 퍼센트 렌더링
	playerJudgementPercentageText.setPosition(-camera.getViewSize() / 2.f + Vector2f(2.f, 1.f)); // view 중심 (0, 0)으로부터 계산되는 position, 왼쪽 위로 설정됨
	playerJudgementPercentageText.setString("Judgement: " + Util::floatToString(player.getJudgementPercentage(), 2) + "%");
	renderer._target.draw(playerJudgementPercentageText);

	// 판정등급 렌더링
	playerJudgementText.setPosition(-camera.getViewSize() / 2.f + Vector2f(2.f, 5.f));
	playerJudgementText.setString(player.getJudgementCurrent());
	renderer._target.draw(playerJudgementText);

	// 코인 획득 수 렌더링
	playerCoinText.setPosition(Vector2f(camera.getViewSize().x / 2.f, -camera.getViewSize().y / 2.f) + Vector2f(-13.f, 1.f));
	playerCoinText.setString("Coin: " + to_string(Game::getInstance().getPlayer().getCoin()));
	renderer._target.draw(playerCoinText);

	// 게임 일시정지 되었을 때 배경화면 지정
	if (player._isDead)
	{
		backgroundWhenPaused.setScale(camera.getViewSize());
		renderer._target.draw(backgroundWhenPaused); 

		//gameOverText.setPosition(Vector2f(0.f, camera.getViewSize().y / 2.f) + Vector2f(0.f, -5.f));
		gameOverText.setString("Game Over!\nPress Enter to Restart");
		// Text origin을 중심으로 배치
		FloatRect textBounds = gameOverText.getLocalBounds();
		gameOverText.setOrigin(textBounds.left + textBounds.width / 2.0f, textBounds.top + textBounds.height / 2.0f);
		renderer._target.draw(gameOverText);
	}
}

void Game::setMapBound(FloatRect mapBound)
{
	_mapBound = mapBound;
}

FloatRect Game::getMapBound()
{
	return _mapBound;
}

void Game::DeleteObject(Object* object)
{
	// object iterator가 vector에 존재하면 동적할당 delete 및 vector에서 삭제처리
	const vector<Object*>::iterator& it = find(_objects.begin(), _objects.end(), object);
	if (it != _objects.end())
	{
		delete *it;
		_objects.erase(it);
	}
}

void Game::InitObject()
{
	if (!Physics::world) return; // 이미 월드가 삭제되어 있으면 return 처리

	// object 관리하는 모든 것들 초기화

	Physics::bodiesToDestroy.clear();
	Physics::bodiesSetEnabled.clear();

	for (Object* object : _objects)
		delete object; // 소멸자 호출 + 메모리 정리
	
	_objects.clear();
}
